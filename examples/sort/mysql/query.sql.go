// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sort

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"strings"
)

const listItemsAndSort = `-- name: ListItemsAndSort :many
SELECT id, name, created FROM sort_items
ORDER BY /*SORT:sort_by:*/? /*ORDER:order_dir:*/
`

type ListItemsAndSortParams struct {
	SortBy   sql.NullString
	OrderDir sql.NullString
}

func (q *Queries) ListItemsAndSort(ctx context.Context, arg ListItemsAndSortParams) ([]SortItem, error) {
	query := listItemsAndSort
	var queryParams []interface{}
	valSortBy := any((func() driver.Value {
		v, _ := arg.SortBy.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	if valSortBy == "" {
		valSortBy = "1"
	}
	query = strings.Replace(query, "/*SORT:sort_by:*/?", valSortBy, 1)
	valOrderDir := any((func() driver.Value {
		v, _ := arg.OrderDir.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	valOrderDir = strings.ToLower(valOrderDir)
	if valOrderDir != "asc" && valOrderDir != "desc" {
		valOrderDir = "asc"
	}
	query = strings.Replace(query, "/*ORDER:order_dir:*/", valOrderDir, 1)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SortItem
	for rows.Next() {
		var i SortItem
		if err := rows.Scan(&i.ID, &i.Name, &i.Created); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsAndSortDefAll = `-- name: ListItemsAndSortDefAll :many
SELECT id, name, created FROM sort_items
ORDER BY /*SORT:sort_by:name*/? /*ORDER:order_dir:asc*/
`

type ListItemsAndSortDefAllParams struct {
	SortBy   sql.NullString
	OrderDir sql.NullString
}

func (q *Queries) ListItemsAndSortDefAll(ctx context.Context, arg ListItemsAndSortDefAllParams) ([]SortItem, error) {
	query := listItemsAndSortDefAll
	var queryParams []interface{}
	valSortBy := any((func() driver.Value {
		v, _ := arg.SortBy.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	if valSortBy == "" {
		valSortBy = "name"
	}
	if valSortBy == "" {
		valSortBy = "1"
	}
	query = strings.Replace(query, "/*SORT:sort_by:name*/?", valSortBy, 1)
	valOrderDir := any((func() driver.Value {
		v, _ := arg.OrderDir.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	if valOrderDir == "" {
		valOrderDir = "asc"
	}
	valOrderDir = strings.ToLower(valOrderDir)
	if valOrderDir != "asc" && valOrderDir != "desc" {
		valOrderDir = "asc"
	}
	query = strings.Replace(query, "/*ORDER:order_dir:asc*/", valOrderDir, 1)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SortItem
	for rows.Next() {
		var i SortItem
		if err := rows.Scan(&i.ID, &i.Name, &i.Created); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsAndSortDefField = `-- name: ListItemsAndSortDefField :many
SELECT id, name, created FROM sort_items
ORDER BY /*SORT:sort_by:name*/? /*ORDER:order_dir:*/
`

type ListItemsAndSortDefFieldParams struct {
	SortBy   sql.NullString
	OrderDir sql.NullString
}

func (q *Queries) ListItemsAndSortDefField(ctx context.Context, arg ListItemsAndSortDefFieldParams) ([]SortItem, error) {
	query := listItemsAndSortDefField
	var queryParams []interface{}
	valSortBy := any((func() driver.Value {
		v, _ := arg.SortBy.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	if valSortBy == "" {
		valSortBy = "name"
	}
	if valSortBy == "" {
		valSortBy = "1"
	}
	query = strings.Replace(query, "/*SORT:sort_by:name*/?", valSortBy, 1)
	valOrderDir := any((func() driver.Value {
		v, _ := arg.OrderDir.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	valOrderDir = strings.ToLower(valOrderDir)
	if valOrderDir != "asc" && valOrderDir != "desc" {
		valOrderDir = "asc"
	}
	query = strings.Replace(query, "/*ORDER:order_dir:*/", valOrderDir, 1)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SortItem
	for rows.Next() {
		var i SortItem
		if err := rows.Scan(&i.ID, &i.Name, &i.Created); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsAndSortSingle = `-- name: ListItemsAndSortSingle :many
SELECT id, name, created FROM sort_items
ORDER BY /*SORT:sort_by:*/?
`

func (q *Queries) ListItemsAndSortSingle(ctx context.Context, sortBy sql.NullString) ([]SortItem, error) {
	query := listItemsAndSortSingle
	var queryParams []interface{}
	sortByVal := any((func() driver.Value {
		v, _ := sortBy.Value()
		if v == nil {
			dv := sql.NullString{Valid: true}
			v, _ = dv.Value()
		}
		return v
	})()).(string)
	if sortByVal != "" {
		query = strings.Replace(query, "/*SORT:sort_by:*/?", sortByVal, 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SortItem
	for rows.Next() {
		var i SortItem
		if err := rows.Scan(&i.ID, &i.Name, &i.Created); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
